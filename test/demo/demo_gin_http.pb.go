// Code generated by protoc-generator-go-http. DO NOT EDIT.
// versions:
// - protoc-generator-gin-http
// - protoc             v3.21.12
// source: test/demo.proto

package demo

import (
	gin "github.com/gin-gonic/gin"
	grpc "google.golang.org/grpc"
	metadata "google.golang.org/grpc/metadata"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
//gin.grpc.metadata.

type DemoGinHTTPServerProxy struct {
	cc DemoClient
}

// NewDemoGinProxy
// 使用原生的 grpc.ClientConnInterface 可以使用原生的 grpc
func NewDemoGinProxy(cc grpc.ClientConnInterface) *DemoGinHTTPServerProxy {
	return &DemoGinHTTPServerProxy{cc: NewDemoClient(cc)}
}

// NewDemoGinClientProxy
// 传入 Client 可以使用zrpc 的Client
func NewDemoGinClientProxy(cc DemoClient) *DemoGinHTTPServerProxy {
	return &DemoGinHTTPServerProxy{cc: cc}
}

func DemoGinResponse(ctx *gin.Context, status, code int, msg string, data interface{}) {
	ctx.JSON(status, map[string]interface{}{
		"code": code,
		"msg":  msg,
		"data": data,
	})
}
func (s *DemoGinHTTPServerProxy) Ping0_HTTP_Handler(ctx *gin.Context) {
	var in Request

	if err := ctx.ShouldBindJSON(&in); err != nil {
		DemoGinResponse(ctx, 200, 400, err.Error(), nil)
		return
	}

	md := metadata.New(nil)
	for k, v := range ctx.Request.Header {
		md.Set(k, v...)
	}
	newCtx := metadata.NewIncomingContext(ctx, md)
	out, err := s.cc.Ping(newCtx, &in)
	if err != nil {
		DemoGinResponse(ctx, 200, 500, err.Error(), nil)
		return
	}

	DemoGinResponse(ctx, 200, 200, "success", out)
}

func (s *DemoGinHTTPServerProxy) RegisterDemoHTTPServer(group *gin.RouterGroup) {
	group.POST("/api/grpcDemo/ping", s.Ping0_HTTP_Handler)
}

type UserGinHTTPServerProxy struct {
	cc UserClient
}

// NewUserGinProxy
// 使用原生的 grpc.ClientConnInterface 可以使用原生的 grpc
func NewUserGinProxy(cc grpc.ClientConnInterface) *UserGinHTTPServerProxy {
	return &UserGinHTTPServerProxy{cc: NewUserClient(cc)}
}

// NewUserGinClientProxy
// 传入 Client 可以使用zrpc 的Client
func NewUserGinClientProxy(cc UserClient) *UserGinHTTPServerProxy {
	return &UserGinHTTPServerProxy{cc: cc}
}

func UserGinResponse(ctx *gin.Context, status, code int, msg string, data interface{}) {
	ctx.JSON(status, map[string]interface{}{
		"code": code,
		"msg":  msg,
		"data": data,
	})
}
func (s *UserGinHTTPServerProxy) Get0_HTTP_Handler(ctx *gin.Context) {
	var in UserRequest

	if err := ctx.ShouldBindJSON(&in); err != nil {
		UserGinResponse(ctx, 200, 400, err.Error(), nil)
		return
	}

	md := metadata.New(nil)
	for k, v := range ctx.Request.Header {
		md.Set(k, v...)
	}
	newCtx := metadata.NewIncomingContext(ctx, md)
	out, err := s.cc.Get(newCtx, &in)
	if err != nil {
		UserGinResponse(ctx, 200, 500, err.Error(), nil)
		return
	}

	UserGinResponse(ctx, 200, 200, "success", out)
}

func (s *UserGinHTTPServerProxy) RegisterUserHTTPServer(group *gin.RouterGroup) {
	group.POST("/api/grpcDemo/ping", s.Get0_HTTP_Handler)
}

type BlogServiceGinHTTPServerProxy struct {
	cc BlogServiceClient
}

// NewBlogServiceGinProxy
// 使用原生的 grpc.ClientConnInterface 可以使用原生的 grpc
func NewBlogServiceGinProxy(cc grpc.ClientConnInterface) *BlogServiceGinHTTPServerProxy {
	return &BlogServiceGinHTTPServerProxy{cc: NewBlogServiceClient(cc)}
}

// NewBlogServiceGinClientProxy
// 传入 Client 可以使用zrpc 的Client
func NewBlogServiceGinClientProxy(cc BlogServiceClient) *BlogServiceGinHTTPServerProxy {
	return &BlogServiceGinHTTPServerProxy{cc: cc}
}

func BlogServiceGinResponse(ctx *gin.Context, status, code int, msg string, data interface{}) {
	ctx.JSON(status, map[string]interface{}{
		"code": code,
		"msg":  msg,
		"data": data,
	})
}
func (s *BlogServiceGinHTTPServerProxy) GetArticles0_HTTP_Handler(ctx *gin.Context) {
	var in GetArticlesReq

	if err := ctx.ShouldBindUri(&in); err != nil {
		BlogServiceGinResponse(ctx, 200, 400, err.Error(), nil)
		return
	}

	if err := ctx.ShouldBindQuery(&in); err != nil {
		BlogServiceGinResponse(ctx, 200, 400, err.Error(), nil)
		return
	}

	md := metadata.New(nil)
	for k, v := range ctx.Request.Header {
		md.Set(k, v...)
	}
	newCtx := metadata.NewIncomingContext(ctx, md)
	out, err := s.cc.GetArticles(newCtx, &in)
	if err != nil {
		BlogServiceGinResponse(ctx, 200, 500, err.Error(), nil)
		return
	}

	BlogServiceGinResponse(ctx, 200, 200, "success", out)
}
func (s *BlogServiceGinHTTPServerProxy) GetArticles1_HTTP_Handler(ctx *gin.Context) {
	var in GetArticlesReq

	if err := ctx.ShouldBindQuery(&in); err != nil {
		BlogServiceGinResponse(ctx, 200, 400, err.Error(), nil)
		return
	}

	md := metadata.New(nil)
	for k, v := range ctx.Request.Header {
		md.Set(k, v...)
	}
	newCtx := metadata.NewIncomingContext(ctx, md)
	out, err := s.cc.GetArticles(newCtx, &in)
	if err != nil {
		BlogServiceGinResponse(ctx, 200, 500, err.Error(), nil)
		return
	}

	BlogServiceGinResponse(ctx, 200, 200, "success", out)
}
func (s *BlogServiceGinHTTPServerProxy) CreateArticle0_HTTP_Handler(ctx *gin.Context) {
	var in Article

	if err := ctx.ShouldBindUri(&in); err != nil {
		BlogServiceGinResponse(ctx, 200, 400, err.Error(), nil)
		return
	}

	if err := ctx.ShouldBindJSON(&in); err != nil {
		BlogServiceGinResponse(ctx, 200, 400, err.Error(), nil)
		return
	}

	md := metadata.New(nil)
	for k, v := range ctx.Request.Header {
		md.Set(k, v...)
	}
	newCtx := metadata.NewIncomingContext(ctx, md)
	out, err := s.cc.CreateArticle(newCtx, &in)
	if err != nil {
		BlogServiceGinResponse(ctx, 200, 500, err.Error(), nil)
		return
	}

	BlogServiceGinResponse(ctx, 200, 200, "success", out)
}

func (s *BlogServiceGinHTTPServerProxy) RegisterBlogServiceHTTPServer(group *gin.RouterGroup) {
	group.GET("/v1/author/:author_id/articles", s.GetArticles0_HTTP_Handler)
	group.GET("/v1/articles", s.GetArticles1_HTTP_Handler)
	group.POST("/v1/author/:author_id/articles", s.CreateArticle0_HTTP_Handler)
}
