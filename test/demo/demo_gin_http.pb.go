// Code generated by protoc-generator-go-http. DO NOT EDIT.
// versions:
// - protoc-generator-gin-http
// - protoc             v6.31.1
// source: test/demo.proto

package demo

import (
	gin "github.com/gin-gonic/gin"
	grpc "google.golang.org/grpc"
	metadata "google.golang.org/grpc/metadata"
	http "net/http"
)

// This is a compile-time assertion to ensure that this generated file
//gin.grpc.metadata.http.

type DemoGinHTTPServerProxy struct {
	cc              DemoClient
	responseHandler func(ctx *gin.Context, data interface{}, err error)
}

// NewDemoGinProxy
// 使用原生的 grpc.ClientConnInterface 可以使用原生的 grpc
func NewDemoGinProxy(cc grpc.ClientConnInterface, responseHandler func(ctx *gin.Context, data interface{}, err error)) *DemoGinHTTPServerProxy {
	return &DemoGinHTTPServerProxy{cc: NewDemoClient(cc), responseHandler: responseHandler}
}

// NewDemoGinClientProxy
// 传入 Client 可以使用zrpc 的Client
func NewDemoGinClientProxy(cc DemoClient, responseHandler func(ctx *gin.Context, data interface{}, err error)) *DemoGinHTTPServerProxy {
	return &DemoGinHTTPServerProxy{cc: cc, responseHandler: responseHandler}
}

func DemoGinResponse(ctx *gin.Context, data interface{}, err error) {
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, map[string]interface{}{
			"msg": err.Error(),
		})
	}
	ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": data,
	})
}
func (s *DemoGinHTTPServerProxy) Ping0_HTTP_Handler(ctx *gin.Context) {
	var in Request

	if err := ctx.ShouldBindJSON(&in); err != nil {
		s.responseHandler(ctx, nil, err)
		return
	}

	md := metadata.New(nil)
	for k, v := range ctx.Request.Header {
		md.Set(k, v...)
	}
	newCtx := metadata.NewIncomingContext(ctx, md)
	out, err := s.cc.Ping(newCtx, &in)
	if err != nil {
		s.responseHandler(ctx, out, err)
		return
	}
	s.responseHandler(ctx, out, err)
}

func (s *DemoGinHTTPServerProxy) RegisterDemoHTTPServer(group *gin.RouterGroup) {
	group.POST("/api/grpcDemo/ping", s.Ping0_HTTP_Handler)
}

type UserGinHTTPServerProxy struct {
	cc              UserClient
	responseHandler func(ctx *gin.Context, data interface{}, err error)
}

// NewUserGinProxy
// 使用原生的 grpc.ClientConnInterface 可以使用原生的 grpc
func NewUserGinProxy(cc grpc.ClientConnInterface, responseHandler func(ctx *gin.Context, data interface{}, err error)) *UserGinHTTPServerProxy {
	return &UserGinHTTPServerProxy{cc: NewUserClient(cc), responseHandler: responseHandler}
}

// NewUserGinClientProxy
// 传入 Client 可以使用zrpc 的Client
func NewUserGinClientProxy(cc UserClient, responseHandler func(ctx *gin.Context, data interface{}, err error)) *UserGinHTTPServerProxy {
	return &UserGinHTTPServerProxy{cc: cc, responseHandler: responseHandler}
}

func UserGinResponse(ctx *gin.Context, data interface{}, err error) {
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, map[string]interface{}{
			"msg": err.Error(),
		})
	}
	ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": data,
	})
}
func (s *UserGinHTTPServerProxy) Get0_HTTP_Handler(ctx *gin.Context) {
	var in UserRequest

	if err := ctx.ShouldBindJSON(&in); err != nil {
		s.responseHandler(ctx, nil, err)
		return
	}

	md := metadata.New(nil)
	for k, v := range ctx.Request.Header {
		md.Set(k, v...)
	}
	newCtx := metadata.NewIncomingContext(ctx, md)
	out, err := s.cc.Get(newCtx, &in)
	if err != nil {
		s.responseHandler(ctx, out, err)
		return
	}
	s.responseHandler(ctx, out, err)
}

func (s *UserGinHTTPServerProxy) RegisterUserHTTPServer(group *gin.RouterGroup) {
	group.POST("/api/grpcDemo/ping", s.Get0_HTTP_Handler)
}

type BlogServiceGinHTTPServerProxy struct {
	cc              BlogServiceClient
	responseHandler func(ctx *gin.Context, data interface{}, err error)
}

// NewBlogServiceGinProxy
// 使用原生的 grpc.ClientConnInterface 可以使用原生的 grpc
func NewBlogServiceGinProxy(cc grpc.ClientConnInterface, responseHandler func(ctx *gin.Context, data interface{}, err error)) *BlogServiceGinHTTPServerProxy {
	return &BlogServiceGinHTTPServerProxy{cc: NewBlogServiceClient(cc), responseHandler: responseHandler}
}

// NewBlogServiceGinClientProxy
// 传入 Client 可以使用zrpc 的Client
func NewBlogServiceGinClientProxy(cc BlogServiceClient, responseHandler func(ctx *gin.Context, data interface{}, err error)) *BlogServiceGinHTTPServerProxy {
	return &BlogServiceGinHTTPServerProxy{cc: cc, responseHandler: responseHandler}
}

func BlogServiceGinResponse(ctx *gin.Context, data interface{}, err error) {
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, map[string]interface{}{
			"msg": err.Error(),
		})
	}
	ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": data,
	})
}
func (s *BlogServiceGinHTTPServerProxy) GetArticles0_HTTP_Handler(ctx *gin.Context) {
	var in GetArticlesReq

	if err := ctx.ShouldBindUri(&in); err != nil {
		s.responseHandler(ctx, nil, err)
		return
	}

	if err := ctx.ShouldBindQuery(&in); err != nil {
		s.responseHandler(ctx, nil, err)
		return
	}

	md := metadata.New(nil)
	for k, v := range ctx.Request.Header {
		md.Set(k, v...)
	}
	newCtx := metadata.NewIncomingContext(ctx, md)
	out, err := s.cc.GetArticles(newCtx, &in)
	if err != nil {
		s.responseHandler(ctx, out, err)
		return
	}
	s.responseHandler(ctx, out, err)
}
func (s *BlogServiceGinHTTPServerProxy) GetArticles1_HTTP_Handler(ctx *gin.Context) {
	var in GetArticlesReq

	if err := ctx.ShouldBindQuery(&in); err != nil {
		s.responseHandler(ctx, nil, err)
		return
	}

	md := metadata.New(nil)
	for k, v := range ctx.Request.Header {
		md.Set(k, v...)
	}
	newCtx := metadata.NewIncomingContext(ctx, md)
	out, err := s.cc.GetArticles(newCtx, &in)
	if err != nil {
		s.responseHandler(ctx, out, err)
		return
	}
	s.responseHandler(ctx, out, err)
}
func (s *BlogServiceGinHTTPServerProxy) CreateArticle0_HTTP_Handler(ctx *gin.Context) {
	var in Article

	if err := ctx.ShouldBindUri(&in); err != nil {
		s.responseHandler(ctx, nil, err)
		return
	}

	if err := ctx.ShouldBindJSON(&in); err != nil {
		s.responseHandler(ctx, nil, err)
		return
	}

	md := metadata.New(nil)
	for k, v := range ctx.Request.Header {
		md.Set(k, v...)
	}
	newCtx := metadata.NewIncomingContext(ctx, md)
	out, err := s.cc.CreateArticle(newCtx, &in)
	if err != nil {
		s.responseHandler(ctx, out, err)
		return
	}
	s.responseHandler(ctx, out, err)
}

func (s *BlogServiceGinHTTPServerProxy) RegisterBlogServiceHTTPServer(group *gin.RouterGroup) {
	group.GET("/v1/author/:author_id/articles", s.GetArticles0_HTTP_Handler)
	group.GET("/v1/articles", s.GetArticles1_HTTP_Handler)
	group.POST("/v1/author/:author_id/articles", s.CreateArticle0_HTTP_Handler)
}
